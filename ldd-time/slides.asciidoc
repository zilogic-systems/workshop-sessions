= Linux Time Management 

== Understanting Time Requirements

=== Time Coupled I/O Operations

  * To blink an LED or scan key press we may need to use soft delays
    between ON/OFF

  * The easiest way to generate such delays is to write a `for`
    loop, as shown below.

[source,c]
------
for (i = 0; i < 100; i++);
------

=== Limitations of Loop Delays

  * There are a couple of problems with such for loops.

    1. It is not possible to accurately generate the required delay.

    2. Even if we are able to calculate the time for the loop, and
       generate an accurate delay. The code may not be portable, and
       the delay will vary with the clock speed of the processor.

=== Calibrated Delays in Kernel

  * To overcome these problems, kernel provides two function variants

  * busyloop delays generated by calibrating the processors
    instruction execution speed

  * The following functions are used to generate nanosecond and
    microsecond delays. 

[source,c]
------
ndelay(unsigned long nanoseconds);
udelay(unsigned long microseconds);
mdelay(unsigned long milliseconds);
------

  * These functions are declared in `linux/delay.h`.

=== CPU Friendly Sleeps

  * A non-busy-waiting variant to generate delay, which puts the
    calling process to sleep is

[source,c]
---- 
void msleep(unsigned int milliseconds);
----

  * sleeps only ensures that the process would start after specified
    time, but not exactly at the specified time.
  
== LED Blinking Using Delay

=== LED Blink Headers

[source,c]
----
include::code/led-blink-delay/led-blink-delay.def[]
----

=== LED Blink Init

[source,c]
----
include::code/led-blink-delay/led-blink-delay.init[]
----
=== LED Blink Exit

[source,c]
----
include::code/led-blink-delay/led-blink-delay.exit[]
----

=== Try Out

* Modify the LED blinking code to blink in green color
  link:{include:code/led-blink-delay/led-blink-delay.full.datauri}["led-blink-delay.c",filename="led-blink-delay.c"]

== Internals of Delay

=== Flow of Time

  * The kernel keeps track flow of time, 
    - for scheduling, 
    - maintain CPU usage time of a process, 
    - to perform periodic and timely actions.

  * The kernel programs a hardware device called `timer`, to generate
    a `periodic interrupt`.

  * In it's interrupt handler, the kernel updates a global counter
    variable. This global counter variable can be used to identify the
    amount of time elapsed since bootup.

=== HearBeat of the Kernel

  * The global counter variable is called `jiffies`. It contains the
    no. of interrupts or ticks that have occurred since boot-up. 
  
  * The variable is declared in `linux/jiffies.h`

  * The timer interrupts are also called timer ticks and it is the
    basic quantum for scheduling.

  * The frequency with which the timer generates an interrupt is
    specified by the macro `HZ` at compile time. 

  * It is defined in `linux/param.h`. It specifies the no. of timer
    interrupts generated per second.

=== Using Jiffies

  * The precision with which, the time can be specified in kernel code
    is '1 / HZ'. 

  * Assuming `HZ as 100`, the time interval between ticks would be `10ms`
    (AKA jiffies interval).

  * In many kernel APIs, the time period is specified in `timer
    ticks or jiffies`. 

  * To specify the delay of 5 seconds, in timer ticks. Considering the
    no. of ticks per second as `HZ`, the no. of ticks in 5 seconds can
    be represented as `5 * HZ`.

=== Knowing HZ

[source,sh]
----
cat /proc/timer_list
----

For every 1 second, we can watch it by

[source,sh]
----
watch -n1 'grep jiffies: /proc/timer_list'
----

=== Implementation of Delay

  * The kernel during boot up, does a delay loop calibration. It
    determines how many delay loops can be executed within a jiffy
    period. This value is stored in the global variable
    `loops_per_jiffy`.

  * The delay loop calibration at boot-up is indicated in the kernel's
    log messages. This can be displayed using the following command.

[source,c]
------
$ dmesg | grep "Calibrating delay loop"
Calibrating delay loop (skipped), value calculated using timer
frequency.. 6629.35 BogoMIPS (lpj=13258704)
------

=== Loops Per Jiffy
	
  * The value specified in `(lpj=...)`, is the loops per jiffy.

  * `loops_per_jiffy * HZ` gives the number of delay loops per
    second. Armed with this information it is easy to generate the
    required delay.

  * delay functions in kernel work by, calculating the required no. of
    delay loops based on `loops_per_jiffy`.


=== Convention for Init

  * The init module are designed to be finite, and of run-to-complete
    type.

  * Init module only sets up the resources and callbacks of driver for
    asynchronous execuction.

  * Only Kernel, calls the registered driver methods on-demand after
    the init.

  * infinite loops, sleeps and longer delays in init module is
    possible, but may hold the insmod command.

  * The better approach would be to defer such activities.

== Deferring in Kernel

=== Deferred Activities

  * Linux kernel provides the methods to defer activities to happen
    later.

  * one such infrastructure is `workqueue`, using which driver can
    queue the activities for the future execution.

== LED Blinking Using Workqueues

=== LED Blink Workqueue Definition

[source,c]
----
include::code/led-blink-wq/led-blink-wq.def[]
----

=== LED Blink Workqueue Init

[source,c]
----
include::code/led-blink-wq/led-blink-wq.init[]
----
=== LED Blink Workqueue Exit

[source,c]
----
include::code/led-blink-wq/led-blink-wq.exit[]
----

=== Try Out

* Modify the LED blinking code to blink in green color
  link:{include:code/led-blink-wq/led-blink-wq.full.datauri}["led-blink-wq.c",filename="led-blink-wq.c"]

=== Using Workqueue

  * Drivers can create a work (workqueue task) and delegate that to a
    global shared workqueue available in the system.

  * `work` is a quantum of code written as a 'C' function, which can
    be executed independently by a workqueue.

  * A way to schedule a timely operation to worker threads is, by
    using `workqueues` API. 

  * The workqueue functions and macros are declared in
    `linux/workqueue.h`

=== Creating Work

  * In a driver, to schedule a work for later execution, a `struct
    work_struct` has to be defined.

  * A convenience for defining and initializing the work statically is
    `DECLARE_DELAYED_WORK()`

[source,c]
------
DECLARE_DELAYED_WORK(work, func)
------

  * `work` is the name of the instance of `struct work_struct`

  * `func` is the function to be invoked when the work is to be
    executed.

  * Alternatively, the `work` structure can be initialized at run time
    using INIT_DELAYED_WORK(work, func).

=== Scheduling Work

  * The work so defined can be scheduled for execution using
    `schedule_delayed_work()`.

[source,c]
------
ret = schedule_delayed_work(workp, delay)

struct work_struct * workp;
unsigned long delay;
int ret;
------

  * The delay is no. of timer ticks after which the work has to be
    executed.

  * Returns `0`, if the work is already scheduled and non-zero
    otherwise.

=== Cancelling Work

  * Cancelling a delayed work can be done by
    `cancel_delayed_work_sync()`

[source,c]
------
ret = cancel_delayed_work_sync(workp)

struct work_struct * workp;
bool ret;
------

  * This function cancels a delayed work. If the work is currently
    being executed then it waits for the work to complete before
    returning.

  * Returns `true` if work was pending, `false` otherwise.

  * If the delayed work reschedules itself, then a flag has to be used
    to stop the work from rescheduling itself.

== Internals of Workqueue

=== Threads in Kernel

  * Kernel threads are light weight kernel processes, which can run in
    the kernel space. It would have kernel privileges and can access
    kernel data-structures.

  * They get scheduled by the kernel as if like userspace process.

  * List of kernel threads can be obtained as below.

[source,sh]
----
$ ps ax | grep '\[.*\]'
----

=== First Thread

* `init` is the first userspace process started by kernel 

* `kthreadd` is the first kernel space process started by kernel whose
  pid is `2`.

* `kthreadd` is the parent of all kernel threads. 

* Consider a pid of kernel thread and check its parent as 

----
$ cat /proc/1591/status | grep PPid
----

=== Worker Threads

  * The kernel can be requested to perform an operation at a later
    point of time. This can be done by requesting kernel to schedule
    the timely operations in kernel threads.

  * Worker threads (AKA `kworkers`) are the special, global kernel
    threads used to execute code on behalf of other drivers.

  * A set of worker threads per cpu, are created and started by the
    kernel at boot-up and it is referred as `worker thread pool`.

=== Viewing Worker Threads

  * `ps` command would list the worker threads running in the system
    as, `[kworker/<cpu>:<instance><prio>]`, where it shows, kworker
    threads designated to each CPU and instance number of it.

[source,sh]
----
ps ax | grep '\[kworker.*\]'
----

=== Workqueue

  * These threads can be assigned with the `works`, from the
    `workqueue`.

  * The works from the workqueue are dispatched to worker threads by a
    workqueue scheduler, which keeps at-least one available work
    running on each CPU, at any point of time.

=== Workqueue And Worker Threads 

image::figures/workqueue.png["Workqueue", align="center",width=732]

=== Try Out 1 - Key Scan 

* Modify the LED blinking code to use for key scanning
  link:{include:code/led-blink-wq/led-blink-wq.full.datauri}["led-blink-wq.c",filename="led-blink-wq.c"]

=== Key Scan - Definitions

[source,c]
-----
include::code/key-scan/key-scan.def[]
-----

=== Key Scan - Init

[source,c]
-----
include::code/key-scan/key-scan.init[]
-----

== Function Call Debugging

=== Ftrace

* Tracing utility part of Linux kernel

* Allows function tracing and callgraph

* This facility can be accessed through 

[source,sh]
----
$ ls /sys/kernel/debug/tracing
----

=== Workqueue Debugging

* enable work event for tracing and capture the trace pipe for few
  seconds.

[source,sh]
----
$ echo workqueue:workqueue_queue_work > /sys/kernel/debug/tracing/set_event

$ cat /sys/kernel/debug/tracing/trace_pipe > out.txt

$ cat out.txt | grep "blink_led"
----

== Exercises

=== Workqueue & GPIO - Key and LED

  * Modify the Keyscan code
    link:{include:code/key-scan/key-scan.full.datauri}["key-scan.c",filename="key-scan.c"],
    to glow

    - Red LED, when Key 1 pressed
    - Green LED, when Key 2 pressed 

=== Modules Param - LED Color Through 

* Modify the workqueue code for blinking, to get the LED color through
  modules param.
